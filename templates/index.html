<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Classifier</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .canvas-container {
            border: 2px solid #666;
            background-color: black; /* Input canvas background */
            cursor: crosshair;
            touch-action: none; /* Prevent scrolling on touch devices */
        }
        #outputCanvas {
            border: 2px solid #666;
            background-color: lightgrey; /* Processed canvas background */
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
        }
        #checkButton {
            background-color: #FFC0CB; /* Pink */
            color: #333;
        }
        #clearButton {
            background-color: #D3D3D3; /* Light grey */
            color: #333;
        }
        #predictionText {
            margin-top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .probabilities-container {
            margin-top: 20px;
            width: 400px;
        }
        .bar-chart {
            display: flex;
            align-items: flex-end;
            height: 150px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: white;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
        .bar-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1;
            text-align: center;
        }
        .bar {
            width: 80%;
            background-color: #D3D3D3;
            margin: 0 2%;
            transition: height 0.3s ease, background-color 0.3s ease;
        }
        .bar.predicted {
            background-color: #4A86E8; /* Blue for predicted */
        }
        .bar-label {
            font-size: 12px;
            margin-top: 5px;
        }
        .bar-value {
            font-size: 10px;
            color: #555;
        }
    </style>
</head>
<body>
    <h1>Handwritten Digit Classifier</h1>

    <div class="container">
        <div>
            <h3>Draw a digit (0-9)</h3>
            <canvas id="inputCanvas" width="280" height="280" class="canvas-container"></canvas>
        </div>
        <div>
            <h3>Processed (28x28)</h3>
            <canvas id="outputCanvas" width="280" height="280"></canvas>
        </div>
    </div>

    <div class="controls">
        <button id="checkButton">Check Digit</button>
        <button id="clearButton">Clear</button>
    </div>

    <div id="predictionText">Prediction: -</div>

    <div class="probabilities-container">
        <h3>Probabilities</h3>
        <div class="bar-chart" id="barChart">
            <!-- Bars will be generated by JavaScript -->
        </div>
    </div>

    <script>
        const inputCanvas = document.getElementById('inputCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const inputCtx = inputCanvas.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');
        const checkButton = document.getElementById('checkButton');
        const clearButton = document.getElementById('clearButton');
        const predictionText = document.getElementById('predictionText');
        const barChart = document.getElementById('barChart');

        let drawing = false;
        let lastX, lastY;

        // Initialize canvases
        function initializeCanvases() {
            inputCtx.fillStyle = 'black';
            inputCtx.fillRect(0, 0, inputCanvas.width, inputCanvas.height);
            outputCtx.fillStyle = 'lightgrey';
            outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
            drawInitialBars();
        }
        
        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.touches[0].clientX - rect.left,
                y: evt.touches[0].clientY - rect.top
            };
        }

        function startDrawing(e) {
            drawing = true;
            const pos = e.touches ? getTouchPos(inputCanvas, e) : getMousePos(inputCanvas, e);
            [lastX, lastY] = [pos.x, pos.y];
            e.preventDefault(); // Prevent scrolling when drawing
        }

        function draw(e) {
            if (!drawing) return;
            const pos = e.touches ? getTouchPos(inputCanvas, e) : getMousePos(inputCanvas, e);
            inputCtx.beginPath();
            inputCtx.strokeStyle = 'white';
            inputCtx.lineWidth = 20; // Increased for better visibility and thicker lines
            inputCtx.lineCap = 'round';
            inputCtx.lineJoin = 'round';
            inputCtx.moveTo(lastX, lastY);
            inputCtx.lineTo(pos.x, pos.y);
            inputCtx.stroke();
            [lastX, lastY] = [pos.x, pos.y];
            e.preventDefault(); // Prevent scrolling when drawing
        }

        function stopDrawing(e) {
            if (drawing) {
                drawing = false;
                // Update the processed image preview immediately after drawing stops
                updateProcessedCanvas();
            }
            e.preventDefault();
        }

        inputCanvas.addEventListener('mousedown', startDrawing);
        inputCanvas.addEventListener('mousemove', draw);
        inputCanvas.addEventListener('mouseup', stopDrawing);
        inputCanvas.addEventListener('mouseout', stopDrawing); // Stop if mouse leaves canvas

        // Touch events
        inputCanvas.addEventListener('touchstart', startDrawing);
        inputCanvas.addEventListener('touchmove', draw);
        inputCanvas.addEventListener('touchend', stopDrawing);
        inputCanvas.addEventListener('touchcancel', stopDrawing);


        function updateProcessedCanvas() {
            // Create a temporary 28x28 canvas to draw the scaled down image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 28;
            tempCanvas.height = 28;
            const tempCtx = tempCanvas.getContext('2d');

            // Get bounding box of the drawing on the input canvas
            const imgData = inputCtx.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
            const data = imgData.data;
            let minX = inputCanvas.width, minY = inputCanvas.height, maxX = 0, maxY = 0;
            let foundPixel = false;

            for (let y = 0; y < inputCanvas.height; y++) {
                for (let x = 0; x < inputCanvas.width; x++) {
                    const alpha = data[(y * inputCanvas.width + x) * 4 + 3]; // Check alpha or any color channel if non-transparent
                    const r = data[(y * inputCanvas.width + x) * 4];
                    if (r > 0) { // Assuming white on black, so check red channel
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                        foundPixel = true;
                    }
                }
            }

            if (!foundPixel) {
                outputCtx.fillStyle = 'lightgrey';
                outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                return; // Nothing drawn
            }

            const boundingWidth = maxX - minX;
            const boundingHeight = maxY - minY;

            if (boundingWidth <= 0 || boundingHeight <= 0) {
                 outputCtx.fillStyle = 'lightgrey';
                outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                return; // No valid bounding box
            }
            
            const targetFitSize = 22; // Fit into 22x22 box
            let newWidth, newHeight;

            if (boundingWidth > boundingHeight) {
                newWidth = targetFitSize;
                newHeight = Math.max(1, Math.round(boundingHeight * (newWidth / boundingWidth)));
            } else {
                newHeight = targetFitSize;
                newWidth = Math.max(1, Math.round(boundingWidth * (newHeight / boundingHeight)));
            }

            // Create a canvas for the cropped image
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = boundingWidth;
            cropCanvas.height = boundingHeight;
            const cropCtx = cropCanvas.getContext('2d');
            cropCtx.drawImage(inputCanvas, minX, minY, boundingWidth, boundingHeight, 0, 0, boundingWidth, boundingHeight);
            
            // Create a canvas for the resized cropped image
            const resizedCropCanvas = document.createElement('canvas');
            resizedCropCanvas.width = newWidth;
            resizedCropCanvas.height = newHeight;
            const resizedCropCtx = resizedCropCanvas.getContext('2d');
            resizedCropCtx.drawImage(cropCanvas, 0, 0, boundingWidth, boundingHeight, 0, 0, newWidth, newHeight);

            // Paste onto the 28x28 temp canvas (centered)
            tempCtx.fillStyle = 'black';
            tempCtx.fillRect(0, 0, 28, 28);
            const pasteX = Math.floor((28 - newWidth) / 2);
            const pasteY = Math.floor((28 - newHeight) / 2);
            tempCtx.drawImage(resizedCropCanvas, pasteX, pasteY);

            // Display this 28x28 image on the outputCanvas (scaled up)
            outputCtx.imageSmoothingEnabled = false; // Use nearest neighbor for pixel art
            outputCtx.fillStyle = 'lightgrey';
            outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
            outputCtx.drawImage(tempCanvas, 0, 0, 28, 28, 0, 0, outputCanvas.width, outputCanvas.height);
        }


        clearButton.addEventListener('click', () => {
            initializeCanvases();
            predictionText.textContent = 'Prediction: -';
        });

        checkButton.addEventListener('click', async () => {
            // The preprocessing for the model is done on the server from the raw 280x280 image.
            // The client-side processed image is just for display.
            const imageDataURL = inputCanvas.toDataURL('image/png');
            updateProcessedCanvas(); // Ensure processed view is up-to-date

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image: imageDataURL }),
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                predictionText.textContent = `Prediction: ${data.prediction}`;
                updateProbabilityBars(data.probabilities, data.prediction);
            } catch (error) {
                console.error('Error during prediction:', error);
                predictionText.textContent = `Error: ${error.message}`;
                drawInitialBars(); // Reset bars on error
            }
        });

        function drawInitialBars() {
            barChart.innerHTML = ''; // Clear existing bars
            for (let i = 0; i < 10; i++) {
                const barContainer = document.createElement('div');
                barContainer.className = 'bar-container';
                
                const barValue = document.createElement('div');
                barValue.className = 'bar-value';
                barValue.textContent = (0.0).toFixed(2);

                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = '1px'; // Minimal height for empty bar

                const barLabel = document.createElement('div');
                barLabel.className = 'bar-label';
                barLabel.textContent = i;

                barContainer.appendChild(barValue);
                barContainer.appendChild(bar);
                barContainer.appendChild(barLabel);
                barChart.appendChild(barContainer);
            }
        }

        function updateProbabilityBars(probabilities, predictedDigit) {
            barChart.innerHTML = ''; // Clear existing bars
            const maxProb = Math.max(...probabilities);

            for (let i = 0; i < 10; i++) {
                const prob = probabilities[i];
                const barContainer = document.createElement('div');
                barContainer.className = 'bar-container';

                const barValue = document.createElement('div');
                barValue.className = 'bar-value';
                barValue.textContent = prob.toFixed(2);
                
                const bar = document.createElement('div');
                bar.className = 'bar';
                bar.style.height = `${Math.max(1, (prob / 1.0) * 100)}%`; // Ensure at least 1px height
                if (i === predictedDigit) {
                    bar.classList.add('predicted');
                }

                const barLabel = document.createElement('div');
                barLabel.className = 'bar-label';
                barLabel.textContent = i;

                barContainer.appendChild(barValue);
                barContainer.appendChild(bar);
                barContainer.appendChild(barLabel);
                barChart.appendChild(barContainer);
            }
        }

        // Initialize
        initializeCanvases();
    </script>
</body>
</html>
